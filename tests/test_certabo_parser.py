#!/usr/bin/env python3

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

import typing

import unittest
from unittest.mock import call, patch

from certabo.parser import (
    BoardTranslator,
    CalibrationCallback,
    CertaboBoardMessageParser,
    CertaboCalibrator,
    CertaboPiece,
    Parser,
)


class SimpleTestTranslator(BoardTranslator):

    def __init__(self):
        super().__init__()
        self.piece_recognition = False
        self.board = []
        self.occupied = []

    def translate(self, board: typing.List[CertaboPiece]):
        self.board = board

    def translate_occupied_squares(self, occupied: typing.List[int]):
        self.occupied = occupied

    def has_piece_recognition(self, value: bool):
        self.piece_recognition = value

    def calibration_complete_square(self, square: int):
        pass

    def calibration_error(self):
        pass


class SimpleTestCalibrationCallback(CalibrationCallback):

    def __init__(self):
        self.stones = None

    def calibration_complete(self, stones: typing.Dict[CertaboPiece, typing.Optional[str]]):
        self.stones = stones

    def calibration_complete_square(self, square: int):
        pass

    def calibration_error(self):
        pass


@patch("certabo.parser.BoardTranslator")
class TestParser(unittest.TestCase):

    def test_parse_position(self, MockedParserCallback):
        data = bytearray(
            ":3 0 84 252 153 196 3 166 0 65 3 0 84 2 3 3 0 83 177 224 3 0 84 \n"
            "107 52 3 0 84 240 106 14 142 7 225 207 3 0 84 255 174 3 0 84 44 \n"
            "81 3 0 84 121 210 3 0 84 242 13 3 0 84 78 193 3 0 84 107 56 3 0 \n"
            "84 240 84 3 0 84 240 65 3 0 84 68 134 0 0 0 0 0 0 0 0 0 0 3 0 85\n"
            " 0 104 223 138 7 0 0 0 0 0 0 0 3 0 85 0 107 0 0 0 0 0 128 51 96 \n"
            "3 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 83 4 2 60 \n"
            "231 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 128 55 111 195 164 1\n"
            "42 128 160 240 1 0 0 0 0 0 216 16 16 48 212 0 0 0 0 0 3 0 84 252\n"
            " 15 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n"
            "0 0 0 0 0 0 0 0 0 0 3 0 84 242 11 3 0 84 68 112 3 0 85 1 184 3 0\n"
            " 84 78 209 3 0 84 44 165 3 0 84 78 216 3 0 84 237 98 0 0 0 0 0 3\n"
            " 0 85 0 16 3 0 83 229 13 3 0 84 106 231 3 0 84 121 142 3 0 84 10\n"
            "5 128 3 0 85 0 67 3 0 84 247 87 3 0 84 252 17\n"
            "0 \r\n",
            encoding="UTF-8",
        )
        Parser(MockedParserCallback).parse(data)
        MockedParserCallback.translate.assert_called_once()

    def test_parse_two_different_positions_calls_translate_twice(self, MockedParserCallback):
        data = bytearray(
            ":3 0 84 252 153 251 196 0 47 128 3 0 84 240 106 3 0 83 177 224 3\n"
            " 0 84 107 52 3 0 84 2 3 152 11 175 70 64 3 0 84 255 174 3 0 84 4\n"
            "4 81 3 0 84 121 210 3 0 84 242 13 3 0 84 78 193 0 0 0 0 0 3 0 84\n"
            " 240 84 3 0 84 240 65 3 0 84 68 134 0 0 0 0 0 0 0 0 0 0 3 0 85 0\n"
            " 104 134 15 159 4 129 0 0 0 0 0 3 0 85 0 107 0 0 0 0 0 8 12 216 \n"
            "32 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 84 107 56 176 \n"
            "49 208 124 0 80 31 33 199 0 0 0 0 0 0 239 26 167 167 192 220 198\n"
            " 252 184 16 246 252 243 126 4 0 0 0 0 0 3 0 84 242 11 32 0 0 60 \n"
            "207 0 0 0 0 0 3 0 84 252 170 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n"
            " 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 84 44 165 3 0 8\n"
            "4 68 112 3 0 85 1 184 3 0 84 78 209 0 0 0 0 0 3 0 84 78 216 3 0 \n"
            "84 237 98 0 0 0 0 0 3 0 85 0 16 3 0 83 229 13 3 0 85 0 67 3 0 84\n"
            " 121 142 3 0 84 105 128 3 0 84 106 231 3 0 84 247 87 3 0 84 252 \n"
            "15 \r\n"
            "L\r\n"
            "\r\n"
            ":3 0 84 252 153 12 6 128 231 0 3 0 84 240 106 3 0 83 177 224 3 0\n"
            " 84 107 52 3 0 84 2 3 0 0 0 0 0 3 0 84 255 174 3 0 84 44 81 3 0 \n"
            "84 121 210 3 0 84 242 13 3 0 84 78 193 229 151 161 128 64 3 0 84\n"
            " 240 84 3 0 84 240 65 3 0 84 68 134 223 162 32 187 67 47 230 96 \n"
            "55 4 3 0 85 0 104 0 0 0 0 0 0 0 0 0 0 3 0 85 0 107 0 0 0 0 0 248\n"
            " 188 143 128 0 221 151 217 128 243 111 27 163 4 1 197 97 181 0 0\n"
            " 171 190 226 0 132 3 0 84 107 56 247 197 97 6 136 123 50 40 32 2\n"
            "1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 232 31 4 76 0 0 0 0 0 0 3 0 84 2\n"
            "42 11 243 32 0 128 1 0 0 0 0 0 3 0 84 252 170 0 0 0 0 0 0 0 0 0 \n"
            "0 94 240 0 11 210 188 218 14 112 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n"
            " 0 0 0 0 0 3 0 84 44 165 3 0 84 68 112 3 0 85 1 184 3 0 84 78 20\n"
            "9 254 152 1 224 80 3 0 84 78 216 3 0 84 237 98 131 48 0 0 0 3 0 \n"
            "85 0 16 3 0 83 229 13 3 0 85 0 67 3 0 84 121 142 3 0 84 105 128 \n"
            "3 0 84 106 231 3 0 84 247 87 3 0 84 252 15 \n",
            encoding="UTF-8",
        )
        Parser(MockedParserCallback).parse(data)
        self.assertEqual(2, MockedParserCallback.translate.call_count)

    def test_parse_invalid(self, MockedParserCallback):
        data = bytearray(
            ":3 0 84 252 153 196 3 166 0 65 3 0 84 2 3 3 0 83 177 224 3 0 84 \n"
            + "107 52 3 0 84 240 106 14 142 7 225 207 3 0 84 255 174 3 0 84 44 \n"
            "81 3 0 84 121 210 3 0 84 242 13 3 0 84 78 193 3 0 84 107 56 3 0 \n"
            "84 240 84 3 0 84 240 65 3 0 84 68 134 0 0 0 0 0 0 0 0 0 0 3 0 85\n"
            " 0 104 2XXXXXXXX23 138 7 0 0 0 0 0 0 0 3 0 85 0 107 0 0 0 0 0 128 51 96 \n"
            "3 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 83 4 2 60 \n"
            "231 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 128 55 111 195 164 1\n"
            "42 128 160 240 1 0 0 0 0 0 216 16 16 48 212 0 0 0 0 0 3 0 84 252\n"
            " 15 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n"
            "0 0 0 0 0 0 0 0 0 0 3 0 84 242 11 3 0 84 68 112 3 0 85 1 184 3 0\n"
            " 84 78 209 3 0 84 44 165 3 0 84 78 216 3 0 84 237 98 0 0 0 0 0 3\n"
            " 0 85 0 16 3 0 83 229 13 3 0 84 106 231 3 0 84 121 142 3 0 84 10\n"
            "5 128 3 0 85 0 67 3 0 84 247 87 3 0 84 252 17\n"
            "0 \r\n",
            encoding="UTF-8",
        )
        Parser(MockedParserCallback).parse(data)
        MockedParserCallback.translate.assert_not_called()

    def test_parse_position_with_junk_in_front(self, _):
        data = bytearray(
            "xxxxxxxxxxxxxxxxxx:3 0 84 252 153 3 0 85 0 104 3 0 84 2 3 3 0 83 177 224 3 0 84 107 52 3 0 84 240 106 "
            "3 0 85 0 107 3 0 84 255 174 3 0 84 44 81 3 0 84 121 210 3 0 84 242 13 3 0 84 107 56 3 0 84 78 193 "
            "3 0 84 240 84 3 0 84 240 65 3 0 84 68 134 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 160 80 "
            "7 140 126 32 250 15 0 0 254 7 118 237 181 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 "
            "0 160 225 80 192 121 0 0 0 0 0 207 224 74 7 172 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 85 1 184 0 0 0 0 0 "
            "0 0 0 0 0 100 115 213 250 161 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 186 10 56 165 201 0 0 0 0 0 168 "
            "94 211 7 40 74 124 195 174 25 3 0 84 44 165 3 0 84 68 112 3 0 84 237 98 3 0 84 252 170 0 0 0 0 0 3 0 "
            "84 78 209 3 0 84 242 11 3 0 84 78 216 3 0 85 0 16 3 0 83 229 13 3 0 85 0 67 3 0 84 121 142 3 0 84 105 "
            "128 3 0 84 106 231 3 0 84 247 87 3 0 84 252 15\r\n",
            encoding="UTF-8",
        )
        callback = SimpleTestTranslator()
        Parser(callback).parse(data)
        # check last piece
        self.assertEqual(CertaboPiece(piece_id=bytearray(b"\x03\x00\x54\xfc\x0f")), callback.board[-1])

    def test_certabo_has_piece_recognition(self, _):
        data = bytearray(
            ":3 0 84 252 153 3 0 85 0 104 3 0 84 2 3 3 0 83 177 224 3 0 84 107 52 3 0 84 240 106 "
            "3 0 85 0 107 3 0 84 255 174 3 0 84 44 81 3 0 84 121 210 3 0 84 242 13 3 0 84 107 56 3 0 84 78 193 "
            "3 0 84 240 84 3 0 84 240 65 3 0 84 68 134 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 160 80 "
            "7 140 126 32 250 15 0 0 254 7 118 237 181 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 "
            "0 160 225 80 192 121 0 0 0 0 0 207 224 74 7 172 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 85 1 184 0 0 0 0 0 "
            "0 0 0 0 0 100 115 213 250 161 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 186 10 56 165 201 0 0 0 0 0 168 "
            "94 211 7 40 74 124 195 174 25 3 0 84 44 165 3 0 84 68 112 3 0 84 237 98 3 0 84 252 170 0 0 0 0 0 3 0 "
            "84 78 209 3 0 84 242 11 3 0 84 78 216 3 0 85 0 16 3 0 83 229 13 3 0 85 0 67 3 0 84 121 142 3 0 84 105 "
            "128 3 0 84 106 231 3 0 84 247 87 3 0 84 252 15\r\n",
            encoding="UTF-8",
        )
        callback = SimpleTestTranslator()
        Parser(callback).parse(data)
        self.assertTrue(callback.piece_recognition)

    def test_parse_position_in_two_parts(self, _):
        data1 = bytearray(
            ":3 0 84 252 153 3 0 85 0 104 3 0 84 240 106 3 0 83 177 224 3 0 8\n"
            "4 107 52 3 0 84 2 3 3 0 85 0 107 3 0 84 255 174 3 0 84 44 81 3 0\n"
            " 84 121 210 3 0 84 242 13 3 0 84 78 193 3 0 84 107 56 3 0 84 240\n"
            " 84 3 0 84 240 65 3 0 84 68 134 252 64 88 0 32 0 0 0 0 0 0 0 0 0\n"
            " 0 0 0 0 0 0 239 108 5 136 0 243 32 12 0 240 0 0 0 0 0 251 13 24\n"
            "1 4 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 221 12\n"
            " 87 1 12 255 194 176 204 0 0 0 0 0 0 226 2 224 8 96 143 182 230 \n"
            "16 5 120 132 14 0 16 0 0 0 0 0 204 146 3 24 0 231 0 20 3 3 0 0 0\n"
            " 0 0 121 129 0 5 0 0 0 0 0 0 0 0 0 0 0 112 177 230 48 0 0 0 0 0 \n"
            "0 0 0 0 0 0 0 0 0 0 0 239 134 225 66 240 0 0 0 0 0 3 0 84 44 165\n"
            " 3 0 84 68 112 3 0 85 1 184 3 0 84 78 209 3 0 84 242 11 3 0 84 7\n"
            "8 216 3 0 84 237 98 3 0 84 252 15 3 0 85 0 16 3 0 83 229 13 3 0 \n"
            "85 0 67 3 0 84 121 142 3 0 84 105 128 3 0 84 106 231 3 0 84 247 \n"
            "87 3 0 84 252 17",
            encoding="UTF-8",
        )
        data2 = bytearray("0\nL\r\n", encoding="UTF-8")
        callback = SimpleTestTranslator()
        parser = Parser(callback)
        parser.parse(data1)
        parser.parse(data2)
        # check last piece
        self.assertEqual(CertaboPiece(piece_id=bytearray(b"\x03\x00\x54\xfc\xaa")), callback.board[-1])

    def test_parse_position_tabutronic_sentio(self, MockedParserCallback):
        data = bytearray(":255 255 0 0 0 0 255 255 \r\n", encoding="UTF-8")
        Parser(MockedParserCallback).parse(data)
        MockedParserCallback.translate_occupied_squares.assert_called_once()

    def test_tabutronic_sentio_has_no_piece_recognition(self, _):
        data = bytearray(":255 255 0 0 0 0 255 255 \r\n", encoding="UTF-8")
        callback = SimpleTestTranslator()
        Parser(callback).parse(data)
        self.assertFalse(callback.piece_recognition)

    def test_parse_position_tabutronic_sentio_with_led_ack(self, _):
        data = bytearray(":255 255 0 0 0 0 255 254\nL\r\n", encoding="UTF-8")
        callback = SimpleTestTranslator()
        Parser(callback).parse(data)
        expected = [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
        ]
        self.assertEqual(expected, callback.occupied)


@patch("certabo.parser.CalibrationCallback")
class TestCalibrator(unittest.TestCase):

    def test_calibration_complete(self, MockedCalibratorCallback):
        c = CertaboCalibrator(MockedCalibratorCallback)
        c.calibrate(
            bytearray(
                "3 0 84 252 153 3 0 85 0 104 3 0 84 2 3 3 0 83 177 224 3 0 84 107 52 3 0 84 240 106 3 0 85 0 107 3 0 84 "
                "255 174 3 0 84 44 81 3 0 84 121 210 3 0 84 242 13 3 0 84 107 56 3 0 84 78 193 3 0 84 240 84 3 0 84 240 "
                "65 3 0 84 68 134 118 144 181 62 197 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 217 253 175 8 35 0 0 0 0 0 "
                "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 114 85 242 66 216 0 0 0 0 0 83 11 112 12 24 186 1 169 "
                "12 164 250 132 247 7 20 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 217 253 174 18 155 0 0 0 0 0 121 34 76 "
                "2 42 0 0 0 0 0 218 65 165 5 112 0 0 0 0 0 170 11 16 170 222 170 47 132 30 7 0 0 0 0 0 14 90 80 27 133 "
                "0 0 0 0 0 3 0 84 44 165 3 0 84 68 112 3 0 84 237 98 3 0 84 252 170 3 0 85 1 184 3 0 84 78 209 3 0 84 242 "
                "11 3 0 84 78 216 3 0 85 0 16 3 0 83 229 13 3 0 85 0 67 3 0 84 121 142 3 0 84 105 128 3 0 84 106 231 3 0 "
                "84 247 87 3 0 84 252 15\r\n",
                encoding="UTF-8",
            )
        )
        c.calibrate(
            bytearray(
                "3 0 84 252 153 3 0 85 0 104 3 0 84 2 3 3 0 83 177 224 3 0 84 107 52 3 0 84 240 106 3 0 85 0 107 3 0 84 "
                "255 174 3 0 84 44 81 3 0 84 121 210 3 0 84 242 13 3 0 84 107 56 3 0 84 78 193 3 0 84 240 84 3 0 84 240"
                " 65 3 0 84 68 134 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 24 161 129 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 "
                "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 202 59 166 9 21 243 192 45 1 80 0 0 0 0 0 0 0 0 0 0 0 "
                "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 80 228 49 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 "
                "0 0 0 0 0 0 0 0 0 0 170 102 170 23 171 0 0 0 0 0 0 0 0 0 0 3 0 84 44 165 3 0 84 68 112 3 0 84 237 98 3 0 "
                "84 252 170 3 0 85 1 184 3 0 84 78 209 3 0 84 242 11 3 0 84 78 216 3 0 85 0 16 3 0 83 229 13 3 0 85 0 67 "
                "3 0 84 121 142 3 0 84 105 128 3 0 84 106 231 3 0 84 247 87 3 0 84 252 15\r\n",
                encoding="UTF-8",
            )
        )
        c.calibrate(
            bytearray(
                "3 0 84 252 153 3 0 85 0 104 3 0 84 2 3 3 0 83 177 224 3 0 84 107 52 3 0 84 240 106 3 0 85 0 107 3 0 84 "
                "255 174 3 0 84 44 81 3 0 84 121 210 3 0 84 242 13 3 0 84 107 56 3 0 84 78 193 3 0 84 240 84 3 0 84 240 "
                "65 3 0 84 68 134 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 16 218 88 139 184 0 0 0 0 0 "
                "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 62 216 31 210 10 0 0 0 0 0 247 12 10 129 250 0 0 0 0 0 0 0 0 0 0 "
                "0 0 0 0 0 92 181 207 8 166 0 0 0 0 0 0 0 0 0 0 133 210 226 37 96 0 0 0 0 0 0 0 0 0 0 165 162 120 93 77 0 "
                "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 172 90 8 5 7 0 0 0 0 0 3 0 84 44 165 3 0 84 68 112 3 0 "
                "84 237 98 3 0 84 252 170 3 0 85 1 184 3 0 84 78 209 3 0 84 242 11 3 0 84 78 216 3 0 85 0 16 3 0 83 229 "
                "13 3 0 85 0 67 3 0 84 121 142 3 0 84 105 128 3 0 84 106 231 3 0 84 247 87 3 0 84 252 15\r\n",
                encoding="UTF-8",
            )
        )
        c.calibrate(
            bytearray(
                "3 0 84 252 153 3 0 85 0 104 3 0 84 2 3 3 0 83 177 224 3 0 84 107 52 3 0 84 240 106 3 0 85 0 107 3 0 84 "
                "255 174 3 0 84 44 81 3 0 84 121 210 3 0 84 242 13 3 0 84 107 56 3 0 84 78 193 3 0 84 240 84 3 0 84 240 "
                "65 3 0 84 68 134 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 81 0 111 152 16 "
                "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 225 241 64 0 133 46 7 134 0 0 0 0 0 0 69 "
                "100 21 209 155 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 "
                "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 129 55 135 224 80 3 0 84 44 165 3 0 84 68 112 3 0 84 237 98 3 "
                "0 84 252 170 3 0 85 1 184 3 0 84 78 209 3 0 84 242 11 3 0 84 78 216 3 0 85 0 16 3 0 83 229 13 3 0 85 0 "
                "67 3 0 84 121 142 3 0 84 105 128 3 0 84 106 231 3 0 84 247 87 3 0 84 252 15\r\n",
                encoding="UTF-8",
            )
        )
        c.calibrate(
            bytearray(
                "3 0 84 252 153 3 0 85 0 104 3 0 84 2 3 3 0 83 177 224 3 0 84 107 52 3 0 84 240 106 3 0 85 0 107 3 0 84 "
                "255 174 3 0 84 44 81 3 0 84 121 210 3 0 84 242 13 3 0 84 107 56 3 0 84 78 193 3 0 84 240 84 3 0 84 240 "
                "65 3 0 84 68 134 0 0 0 0 0 207 92 165 5 26 245 232 148 128 161 0 0 0 0 0 196 72 1 128 21 172 71 4 224 "
                "210 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 144 34 15 "
                "55 160 0 0 0 0 0 0 0 0 0 0 93 22 18 56 95 164 88 112 226 129 0 0 0 0 0 225 17 133 55 10 0 0 0 0 0 0 0 0 "
                "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 84 44 165 3 0 84 "
                "68 112 3 0 84 237 98 3 0 84 252 170 3 0 85 1 184 3 0 84 78 209 3 0 84 242 11 3 0 84 78 216 3 0 85 0 16 3 "
                "0 83 229 13 3 0 85 0 67 3 0 84 121 142 3 0 84 105 128 3 0 84 106 231 3 0 84 247 87 3 0 84 252 15\r\n",
                encoding="UTF-8",
            )
        )
        c.calibrate(
            bytearray(
                "3 0 84 252 153 3 0 85 0 104 3 0 84 2 3 3 0 83 177 224 3 0 84 107 52 3 0 84 240 106 3 0 85 0 107 3 0 84 "
                "255 174 3 0 84 44 81 3 0 84 121 210 3 0 84 242 13 3 0 84 107 56 3 0 84 78 193 3 0 84 240 84 3 0 84 240 "
                "65 3 0 84 68 134 0 0 0 0 0 0 0 0 0 0 90 95 154 60 162 0 0 0 0 0 223 177 96 112 224 70 128 24 7 0 58 168 "
                "95 144 196 240 75 127 160 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 20 16 "
                "5 202 239 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 139 175 129 5 245 0 0 0 "
                "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 84 44 165 3 0 84 68 112 3 "
                "0 84 237 98 3 0 84 252 170 3 0 85 1 184 3 0 84 78 209 3 0 84 242 11 3 0 84 78 216 3 0 85 0 16 3 0 83 229 "
                "13 3 0 85 0 67 3 0 84 121 142 3 0 84 105 128 3 0 84 106 231 3 0 84 247 87 3 0 84 252 15\r\n",
                encoding="UTF-8",
            )
        )
        c.calibrate(
            bytearray(
                "3 0 84 252 153 3 0 85 0 104 3 0 84 2 3 3 0 83 177 224 3 0 84 107 52 3 0 84 240 106 3 0 85 0 107 3 0 84 "
                "255 174 3 0 84 44 81 3 0 84 121 210 3 0 84 242 13 3 0 84 107 56 3 0 84 78 193 3 0 84 240 84 3 0 84 240 "
                "65 3 0 84 68 134 157 233 132 168 48 0 0 0 0 0 58 54 80 28 35 186 2 100 0 20 239 220 64 5 4 0 0 0 0 0 0 "
                "0 0 0 0 188 61 203 17 168 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 197 32 122 20 0 0 0 0 0 "
                "252 232 14 2 17 159 181 46 152 130 0 0 0 0 0 122 54 160 24 13 251 160 77 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 "
                "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 228 90 46 143 34 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 "
                "0 84 44 165 3 0 84 68 112 3 0 84 237 98 3 0 84 252 170 3 0 85 1 184 3 0 84 78 209 3 0 84 242 11 3 0 84 "
                "78 216 3 0 85 0 16 3 0 83 229 13 3 0 85 0 67 3 0 84 121 142 3 0 84 105 128 3 0 84 106 231 3 0 84 247 87 "
                "3 0 84 252 15\r\n",
                encoding="UTF-8",
            )
        )
        MockedCalibratorCallback.calibration_complete.assert_called_once()

    def test_calibration_incomplete(self, MockedCalibratorCallback):
        c = CertaboCalibrator(MockedCalibratorCallback)
        c.calibrate(
            bytearray(
                "1 0 84 252 153 3 0 85 0 104 3 0 84 2 3 3 0 83 177 224 3 0 84 107 52 3 0 84 240 106 3 0 85 0 107 3 0 84 "
                "255 174 3 0 84 44 81 3 0 84 121 210 3 0 84 242 13 3 0 84 107 56 3 0 84 78 193 3 0 84 240 84 3 0 84 240 "
                "65 3 0 84 68 134 118 144 181 62 197 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 217 253 175 8 35 0 0 0 0 0 0 "
                "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 114 85 242 66 216 0 0 0 0 0 83 11 112 12 24 186 1 169 12 "
                "164 250 132 247 7 20 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 217 253 174 18 155 0 0 0 0 0 121 34 76 2 42 "
                "0 0 0 0 0 218 65 165 5 112 0 0 0 0 0 170 11 16 170 222 170 47 132 30 7 0 0 0 0 0 14 90 80 27 133 0 0 0 0 "
                "0 3 0 84 44 165 3 0 84 68 112 3 0 84 237 98 3 0 84 252 170 3 0 85 1 184 3 0 84 78 209 3 0 84 242 11 3 0 "
                "84 78 216 3 0 85 0 16 3 0 83 229 13 3 0 85 0 67 3 0 84 121 142 3 0 84 105 128 3 0 84 106 231 3 0 84 247 "
                "87 3 0 84 252 15\r\n",
                encoding="UTF-8",
            )
        )
        c.calibrate(
            bytearray(
                "2 0 84 252 153 3 0 85 0 104 3 0 84 2 3 3 0 83 177 224 3 0 84 107 52 3 0 84 240 106 3 0 85 0 107 3 0 84 "
                "255 174 3 0 84 44 81 3 0 84 121 210 3 0 84 242 13 3 0 84 107 56 3 0 84 78 193 3 0 84 240 84 3 0 84 240 "
                "65 3 0 84 68 134 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 24 161 129 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 "
                "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 202 59 166 9 21 243 192 45 1 80 0 0 0 0 0 0 0 0 0 0 0 "
                "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 80 228 49 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 "
                "0 0 0 0 0 0 0 0 0 0 170 102 170 23 171 0 0 0 0 0 0 0 0 0 0 3 0 84 44 165 3 0 84 68 112 3 0 84 237 98 3 0 "
                "84 252 170 3 0 85 1 184 3 0 84 78 209 3 0 84 242 11 3 0 84 78 216 3 0 85 0 16 3 0 83 229 13 3 0 85 0 67 "
                "3 0 84 121 142 3 0 84 105 128 3 0 84 106 231 3 0 84 247 87 3 0 84 252 15\r\n",
                encoding="UTF-8",
            )
        )
        c.calibrate(
            bytearray(
                "3 0 84 252 153 3 0 85 0 104 3 0 84 2 3 3 0 83 177 224 3 0 84 107 52 3 0 84 240 106 3 0 85 0 107 3 0 84 "
                "255 174 3 0 84 44 81 3 0 84 121 210 3 0 84 242 13 3 0 84 107 56 3 0 84 78 193 3 0 84 240 84 3 0 84 240 "
                "65 3 0 84 68 134 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 16 218 88 139 184 0 0 0 0 "
                "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 62 216 31 210 10 0 0 0 0 0 247 12 10 129 250 0 0 0 0 0 0 0 0 "
                "0 0 0 0 0 0 0 92 181 207 8 166 0 0 0 0 0 0 0 0 0 0 133 210 226 37 96 0 0 0 0 0 0 0 0 0 0 165 162 120 93 "
                "77 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 172 90 8 5 7 0 0 0 0 0 3 0 84 44 165 3 0 84 68 112 "
                "3 0 84 237 98 3 0 84 252 170 3 0 85 1 184 3 0 84 78 209 3 0 84 242 11 3 0 84 78 216 3 0 85 0 16 3 0 83 "
                "229 13 3 0 85 0 67 3 0 84 121 142 3 0 84 105 128 3 0 84 106 231 3 0 84 247 87 3 0 84 252 15\r\n",
                encoding="UTF-8",
            )
        )
        c.calibrate(
            bytearray(
                "4 0 84 252 153 3 0 85 0 104 3 0 84 2 3 3 0 83 177 224 3 0 84 107 52 3 0 84 240 106 3 0 85 0 107 3 0 84 "
                "255 174 3 0 84 44 81 3 0 84 121 210 3 0 84 242 13 3 0 84 107 56 3 0 84 78 193 3 0 84 240 84 3 0 84 240 "
                "65 3 0 84 68 134 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 81 0 111 152 16 "
                "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 225 241 64 0 133 46 7 134 0 0 0 0 0 0 69 "
                "100 21 209 155 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 "
                "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 129 55 135 224 80 3 0 84 44 165 3 0 84 68 112 3 0 84 237 98 3 "
                "0 84 252 170 3 0 85 1 184 3 0 84 78 209 3 0 84 242 11 3 0 84 78 216 3 0 85 0 16 3 0 83 229 13 3 0 85 0 67 "
                "3 0 84 121 142 3 0 84 105 128 3 0 84 106 231 3 0 84 247 87 3 0 84 252 15\r\n",
                encoding="UTF-8",
            )
        )
        c.calibrate(
            bytearray(
                "2 0 84 252 153 3 0 85 0 104 3 0 84 2 3 3 0 83 177 224 3 0 84 107 52 3 0 84 240 106 3 0 85 0 107 3 0 84 "
                "255 174 3 0 84 44 81 3 0 84 121 210 3 0 84 242 13 3 0 84 107 56 3 0 84 78 193 3 0 84 240 84 3 0 84 240 "
                "65 3 0 84 68 134 0 0 0 0 0 207 92 165 5 26 245 232 148 128 161 0 0 0 0 0 196 72 1 128 21 172 71 4 224 210 "
                "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 144 34 15 55 "
                "160 0 0 0 0 0 0 0 0 0 0 93 22 18 56 95 164 88 112 226 129 0 0 0 0 0 225 17 133 55 10 0 0 0 0 0 0 0 0 0 0 "
                "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 84 44 165 3 0 84 68 "
                "112 3 0 84 237 98 3 0 84 252 170 3 0 85 1 184 3 0 84 78 209 3 0 84 242 11 3 0 84 78 216 3 0 85 0 16 3 0 "
                "83 229 13 3 0 85 0 67 3 0 84 121 142 3 0 84 105 128 3 0 84 106 231 3 0 84 247 87 3 0 84 252 15\r\n",
                encoding="UTF-8",
            )
        )
        c.calibrate(
            bytearray(
                "1 0 84 252 153 3 0 85 0 104 3 0 84 2 3 3 0 83 177 224 3 0 84 107 52 3 0 84 240 106 3 0 85 0 107 3 0 84 "
                "255 174 3 0 84 44 81 3 0 84 121 210 3 0 84 242 13 3 0 84 107 56 3 0 84 78 193 3 0 84 240 84 3 0 84 240 "
                "65 3 0 84 68 134 0 0 0 0 0 0 0 0 0 0 90 95 154 60 162 0 0 0 0 0 223 177 96 112 224 70 128 24 7 0 58 168 "
                "95 144 196 240 75 127 160 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 20 16 "
                "5 202 239 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 139 175 129 5 245 0 0 0 "
                "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 84 44 165 3 0 84 68 112 3 "
                "0 84 237 98 3 0 84 252 170 3 0 85 1 184 3 0 84 78 209 3 0 84 242 11 3 0 84 78 216 3 0 85 0 16 3 0 83 229 "
                "13 3 0 85 0 67 3 0 84 121 142 3 0 84 105 128 3 0 84 106 231 3 0 84 247 87 3 0 84 252 15\r\n",
                encoding="UTF-8",
            )
        )
        c.calibrate(
            bytearray(
                "1 0 84 252 153 3 0 85 0 104 3 0 84 2 3 3 0 83 177 224 3 0 84 107 52 3 0 84 240 106 3 0 85 0 107 3 0 84 "
                "255 174 3 0 84 44 81 3 0 84 121 210 3 0 84 242 13 3 0 84 107 56 3 0 84 78 193 3 0 84 240 84 3 0 84 240 "
                "65 3 0 84 68 134 157 233 132 168 48 0 0 0 0 0 58 54 80 28 35 186 2 100 0 20 239 220 64 5 4 0 0 0 0 0 0 "
                "0 0 0 0 188 61 203 17 168 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 197 32 122 20 0 0 0 0 0 "
                "252 232 14 2 17 159 181 46 152 130 0 0 0 0 0 122 54 160 24 13 251 160 77 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 "
                "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 228 90 46 143 34 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 "
                "0 84 44 165 3 0 84 68 112 3 0 84 237 98 3 0 84 252 170 3 0 85 1 184 3 0 84 78 209 3 0 84 242 11 3 0 84 "
                "78 216 3 0 85 0 16 3 0 83 229 13 3 0 85 0 67 3 0 84 121 142 3 0 84 105 128 3 0 84 106 231 3 0 84 247 87 "
                "3 0 84 252 15\r\n",
                encoding="UTF-8",
            )
        )
        MockedCalibratorCallback.calibration_complete.assert_not_called()


@patch("certabo.parser.ParserCallback")
class TestCertaboBoardMessageParser(unittest.TestCase):

    def test_low_gain_use_most_common(self, MockedParserCallback):
        data1, data2, data3, stones = self._board_data()
        # parse three times, last time with noise
        parser = CertaboBoardMessageParser(MockedParserCallback, True)
        parser.update_stones(stones)
        parser.parse(data1)
        parser.parse(data2)
        parser.parse(data3)
        calls = [
            call("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR"),
            call("rnbqkbnr/ppppppp1/8/8/8/8/PPPPPPPP/RNBQKBNR"),
        ]
        MockedParserCallback.board_update.assert_has_calls(calls)
        self.assertEqual(2, MockedParserCallback.board_update.call_count)

    def test_high_gain(self, MockedParserCallback):
        data1, data2, data3, stones = self._board_data()
        # parse three times, last time with noise
        parser = CertaboBoardMessageParser(MockedParserCallback, False)
        parser.update_stones(stones)
        parser.parse(data1)
        parser.parse(data2)
        parser.parse(data3)
        calls = [
            call("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR"),
            call("rnbqkbnr/ppppppp1/8/8/8/8/PPPPPPPP/RNBQKBNR"),
            call("rnb1k1n1/ppppppp1/8/8/8/8/P1PPPPP1/RNBQKBNR"),
        ]
        MockedParserCallback.board_update.assert_has_calls(calls)
        self.assertEqual(3, MockedParserCallback.board_update.call_count)

    def _board_data(self):
        # initial position
        data1 = bytearray(
            ":48 0 248 71 99 48 0 248 85 159 48 0 177 203 192 48 0 177 215 17 48 0 177 117 59 48 0 177 43 7 48 0 248 "
            "222 81 48 0 247 200 86 48 0 248 114 180 48 0 248 155 251 48 0 248 48 74 48 0 177 236 131 48 0 177 230 12 "
            "48 0 177 187 36 48 0 248 146 97 48 0 248 89 231 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 "
            "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 "
            "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 "
            "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 48 0 248 85 122 48 0 248 68 117 48 0 248 201 109 "
            "48 0 248 144 65 48 0 177 231 217 48 0 248 76 179 48 0 248 161 89 48 0 94 124 14 48 0 248 98 180 48 0 248 "
            "233 43 48 0 248 86 247 48 0 248 145 6 48 0 248 104 144 48 0 248 79 194 48 0 248 134 85 48 0 177 81 73\r\n",
            encoding="UTF-8",
        )
        # pawn removed on h7
        data2 = bytearray(
            ":48 0 248 71 99 48 0 248 85 159 48 0 177 203 192 48 0 177 215 17 48 0 177 117 59 48 0 177 43 7 48 0 248 "
            "222 81 48 0 247 200 86 48 0 248 114 180 48 0 248 155 251 48 0 248 48 74 48 0 177 236 131 48 0 177 230 12 "
            "48 0 177 187 36 48 0 248 146 97 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 "
            "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 "
            "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 "
            "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 48 0 248 85 122 48 0 248 68 117 48 0 248 201 109 "
            "48 0 248 144 65 48 0 177 231 217 48 0 248 76 179 48 0 248 161 89 48 0 94 124 14 48 0 248 98 180 48 0 248 "
            "233 43 48 0 248 86 247 48 0 248 145 6 48 0 248 104 144 48 0 248 79 194 48 0 248 134 85 48 0 177 81 73\r\n",
            encoding="UTF-8",
        )
        # pawn removed on h7, with noise
        data3 = bytearray(
            ":48 0 248 71 99 48 0 248 85 159 48 0 177 203 192 48 0 177 23 19 48 0 177 117 59 48 0 177 43 6 48 0 248 "
            "222 81 48 0 239 200 86 48 0 248 114 180 48 0 248 155 251 48 0 248 48 74 48 0 177 236 131 48 0 177 230 12 "
            "48 0 177 187 36 48 0 248 146 97 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 "
            "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 "
            "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 "
            "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 48 0 248 85 122 48 0 248 73 250 48 0 248 201 109 "
            "48 0 248 144 65 48 0 177 231 217 48 0 248 76 179 48 0 248 161 89 48 0 30 124 13 48 0 248 98 180 48 0 248 "
            "233 43 48 0 248 86 247 48 0 248 145 6 48 0 248 104 144 48 0 248 79 194 48 0 248 134 85 48 0 177 81 73\r\n",
            encoding="UTF-8",
        )
        # calibrate to get stones
        callback = SimpleTestCalibrationCallback()
        calibrator = CertaboCalibrator(callback)
        for i in range(7):
            calibrator.calibrate(data1)
        stones = callback.stones
        return data1, data2, data3, stones


if __name__ == "__main__":
    unittest.main()
